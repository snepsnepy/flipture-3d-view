import { PlaneGeometry as B, CylinderGeometry as b, Object3D as h, Vector3 as d, Color as C, InstancedMesh as f, MeshBasicMaterial as _, ShaderLib as y } from "three";
const P = new B(), m = new b(1, 1, 1);
m.rotateX(Math.PI / 2);
const e = new h(), l = new d(), w = new d(), u = new C("red");
class F extends h {
  constructor({
    skeleton: r = null,
    dotSize: g = 0.33,
    lineWidth: o = 0.025,
    colorStatic: x = "#006CFF",
    colorDynamic: p = "#FC7229",
    extraBoneMultiplier: M = 1
  } = {}) {
    if (super(), !r)
      return console.log(
        "Failed to create WiggleRigHelper: missing skeleton on initialization"
      );
    this.links = r.bones.reduce((t, a) => (a.children.forEach((n) => t.push([a, n])), t), []), this.finalBones = r.bones.filter(
      (t) => t.children.length === 0
    ), this.finalBoneLengths = this.finalBones.map(
      (t) => t.position.length()
    ), this.finalBoneExtensionPositions = this.finalBones.map(() => new d()), this.dots = new f(
      P,
      new L({
        color: 16777215,
        transparent: !0,
        depthTest: !1
      }),
      r.bones.length + this.finalBoneLengths.length
    ), this.dots.renderOrder = 999, this.dots.frustumCulled = !1;
    for (let t = 0; t < r.bones.length + this.finalBones.length; t++)
      u.setStyle(t === 0 ? x : p), this.dots.setColorAt(t, u);
    this.add(this.dots), this.dots.onBeforeRender = (t, a, n) => {
      r.bones.forEach((i, s) => {
        const c = i.getWorldPosition(l);
        e.position.copy(c), e.scale.setScalar(g), e.rotation.copy(n.rotation), e.updateMatrix(), this.dots.setMatrixAt(s, e.matrix);
      }), this.finalBones.forEach((i, s) => {
        l.set(0, this.finalBoneLengths[0] * M, 0);
        const c = i.localToWorld(l);
        this.finalBoneExtensionPositions[s].copy(c), e.position.copy(c), e.scale.setScalar(g), e.rotation.copy(n.rotation), e.updateMatrix(), this.dots.setMatrixAt(r.bones.length + s, e.matrix);
      }), this.dots.instanceMatrix.needsUpdate = !0, this.dots.computeBoundingSphere();
    }, this.lines = new f(
      m,
      new _({
        color: p,
        transparent: !0,
        depthTest: !1
      }),
      this.links.length + this.finalBones.length
    ), e.scale.set(0, 0, 0), e.updateMatrix();
    for (let t = 0; t < this.links.length + this.finalBones.length; t++)
      this.lines.setMatrixAt(t, e.matrix);
    this.lines.renderOrder = 998, this.lines.frustumCulled = !1, this.add(this.lines), this.lines.onBeforeRender = () => {
      this.links.forEach(([t, a], n) => {
        const i = t.getWorldPosition(l), s = a.getWorldPosition(w);
        e.position.copy(i).lerp(s, 0.5), e.scale.set(o, o, i.distanceTo(s)), e.lookAt(i), e.updateMatrix(), this.lines.setMatrixAt(n, e.matrix);
      }), this.finalBones.forEach((t, a) => {
        const n = t.getWorldPosition(l), i = this.finalBoneExtensionPositions[a];
        e.position.copy(n).lerp(i, 0.5), e.scale.set(o, o, n.distanceTo(i)), e.lookAt(n), e.updateMatrix(), this.lines.setMatrixAt(this.links.length + a, e.matrix);
      }), this.lines.instanceMatrix.needsUpdate = !0, this.lines.computeBoundingSphere();
    };
  }
  dispose() {
    super.dispose();
  }
}
class L extends _ {
  constructor(r) {
    super(r), this.uniforms = {
      ...y.standard.uniforms
    }, this.type = "WiggleBonesHelperDotMaterial", this.vertexShader = /* glsl */
    `
      #include <common>
      #include <batching_pars_vertex>
      #include <uv_pars_vertex>
      #include <envmap_pars_vertex>
      #include <color_pars_vertex>
      #include <fog_pars_vertex>
      #include <morphtarget_pars_vertex>
      #include <skinning_pars_vertex>
      #include <logdepthbuf_pars_vertex>
      #include <clipping_planes_pars_vertex>
      varying vec2 vvUv;
      void main() {
        #include <uv_vertex>
        #include <color_vertex>
        #include <morphcolor_vertex>
        #include <batching_vertex>
        #if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
          #include <beginnormal_vertex>
          #include <morphnormal_vertex>
          #include <skinbase_vertex>
          #include <skinnormal_vertex>
          #include <defaultnormal_vertex>
        #endif
        #include <begin_vertex>
        #include <morphtarget_vertex>
        #include <skinning_vertex>
        #include <project_vertex>
        #include <logdepthbuf_vertex>
        #include <clipping_planes_vertex>
        #include <worldpos_vertex>
        #include <envmap_vertex>
        #include <fog_vertex>

        vvUv = uv;
      }
    `, this.fragmentShader = /* glsl */
    `
      uniform vec3 diffuse;
      uniform float opacity;
      #ifndef FLAT_SHADED
        varying vec3 vNormal;
      #endif
      #include <common>
      #include <dithering_pars_fragment>
      #include <color_pars_fragment>
      #include <uv_pars_fragment>
      #include <map_pars_fragment>
      #include <alphamap_pars_fragment>
      #include <alphatest_pars_fragment>
      #include <alphahash_pars_fragment>
      #include <aomap_pars_fragment>
      #include <lightmap_pars_fragment>
      #include <envmap_common_pars_fragment>
      #include <envmap_pars_fragment>
      #include <fog_pars_fragment>
      #include <specularmap_pars_fragment>
      #include <logdepthbuf_pars_fragment>
      #include <clipping_planes_pars_fragment>
      varying vec2 vvUv;
      void main() {
        vec4 diffuseColor = vec4( diffuse, opacity );
        #include <clipping_planes_fragment>
        #include <logdepthbuf_fragment>
        #include <map_fragment>
        #include <color_fragment>
        #include <alphamap_fragment>
        #include <alphatest_fragment>
        #include <alphahash_fragment>
        #include <specularmap_fragment>
        ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
        #ifdef USE_LIGHTMAP
          vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
          reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
        #else
          reflectedLight.indirectDiffuse += vec3( 1.0 );
        #endif
        #include <aomap_fragment>
        reflectedLight.indirectDiffuse *= diffuseColor.rgb;
        vec3 outgoingLight = reflectedLight.indirectDiffuse;
        #include <envmap_fragment>
        #include <opaque_fragment>

        float circ = length(vvUv - vec2(0.5)) * 1.5;
        gl_FragColor.a = smoothstep(0.5, 0.48, circ);
        gl_FragColor.rgb = mix(gl_FragColor.rgb, vec3(1.0), smoothstep(0.35, 0.37, circ));
        gl_FragColor.rgb = mix(vec3(0.0), gl_FragColor.rgb, gl_FragColor.a);

        gl_FragColor.a += smoothstep(0.75, 0.5, circ) * 0.15;
        gl_FragColor.a = clamp(gl_FragColor.a, 0.0, 1.0);
        // gl_FragColor.a *= 0.9;


        #include <tonemapping_fragment>
        #include <colorspace_fragment>
        #include <fog_fragment>
        #include <premultiplied_alpha_fragment>
        #include <dithering_fragment>
      }
    `;
  }
}
export {
  F as WiggleRigHelper
};
