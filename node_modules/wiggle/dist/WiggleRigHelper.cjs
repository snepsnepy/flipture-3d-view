"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const n=require("three"),v=new n.PlaneGeometry,h=new n.CylinderGeometry(1,1,1);h.rotateX(Math.PI/2);const e=new n.Object3D,o=new n.Vector3,x=new n.Vector3,u=new n.Color("red");class M extends n.Object3D{constructor({skeleton:s=null,dotSize:g=.33,lineWidth:c=.025,colorStatic:_="#006CFF",colorDynamic:p="#FC7229",extraBoneMultiplier:m=1}={}){if(super(),!s)return console.log("Failed to create WiggleRigHelper: missing skeleton on initialization");this.links=s.bones.reduce((t,a)=>(a.children.forEach(i=>t.push([a,i])),t),[]),this.finalBones=s.bones.filter(t=>t.children.length===0),this.finalBoneLengths=this.finalBones.map(t=>t.position.length()),this.finalBoneExtensionPositions=this.finalBones.map(()=>new n.Vector3),this.dots=new n.InstancedMesh(v,new b({color:16777215,transparent:!0,depthTest:!1}),s.bones.length+this.finalBoneLengths.length),this.dots.renderOrder=999,this.dots.frustumCulled=!1;for(let t=0;t<s.bones.length+this.finalBones.length;t++)u.setStyle(t===0?_:p),this.dots.setColorAt(t,u);this.add(this.dots),this.dots.onBeforeRender=(t,a,i)=>{s.bones.forEach((r,l)=>{const d=r.getWorldPosition(o);e.position.copy(d),e.scale.setScalar(g),e.rotation.copy(i.rotation),e.updateMatrix(),this.dots.setMatrixAt(l,e.matrix)}),this.finalBones.forEach((r,l)=>{o.set(0,this.finalBoneLengths[0]*m,0);const d=r.localToWorld(o);this.finalBoneExtensionPositions[l].copy(d),e.position.copy(d),e.scale.setScalar(g),e.rotation.copy(i.rotation),e.updateMatrix(),this.dots.setMatrixAt(s.bones.length+l,e.matrix)}),this.dots.instanceMatrix.needsUpdate=!0,this.dots.computeBoundingSphere()},this.lines=new n.InstancedMesh(h,new n.MeshBasicMaterial({color:p,transparent:!0,depthTest:!1}),this.links.length+this.finalBones.length),e.scale.set(0,0,0),e.updateMatrix();for(let t=0;t<this.links.length+this.finalBones.length;t++)this.lines.setMatrixAt(t,e.matrix);this.lines.renderOrder=998,this.lines.frustumCulled=!1,this.add(this.lines),this.lines.onBeforeRender=()=>{this.links.forEach(([t,a],i)=>{const r=t.getWorldPosition(o),l=a.getWorldPosition(x);e.position.copy(r).lerp(l,.5),e.scale.set(c,c,r.distanceTo(l)),e.lookAt(r),e.updateMatrix(),this.lines.setMatrixAt(i,e.matrix)}),this.finalBones.forEach((t,a)=>{const i=t.getWorldPosition(o),r=this.finalBoneExtensionPositions[a];e.position.copy(i).lerp(r,.5),e.scale.set(c,c,i.distanceTo(r)),e.lookAt(i),e.updateMatrix(),this.lines.setMatrixAt(this.links.length+a,e.matrix)}),this.lines.instanceMatrix.needsUpdate=!0,this.lines.computeBoundingSphere()}}dispose(){super.dispose()}}class b extends n.MeshBasicMaterial{constructor(s){super(s),this.uniforms={...n.ShaderLib.standard.uniforms},this.type="WiggleBonesHelperDotMaterial",this.vertexShader=`
      #include <common>
      #include <batching_pars_vertex>
      #include <uv_pars_vertex>
      #include <envmap_pars_vertex>
      #include <color_pars_vertex>
      #include <fog_pars_vertex>
      #include <morphtarget_pars_vertex>
      #include <skinning_pars_vertex>
      #include <logdepthbuf_pars_vertex>
      #include <clipping_planes_pars_vertex>
      varying vec2 vvUv;
      void main() {
        #include <uv_vertex>
        #include <color_vertex>
        #include <morphcolor_vertex>
        #include <batching_vertex>
        #if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
          #include <beginnormal_vertex>
          #include <morphnormal_vertex>
          #include <skinbase_vertex>
          #include <skinnormal_vertex>
          #include <defaultnormal_vertex>
        #endif
        #include <begin_vertex>
        #include <morphtarget_vertex>
        #include <skinning_vertex>
        #include <project_vertex>
        #include <logdepthbuf_vertex>
        #include <clipping_planes_vertex>
        #include <worldpos_vertex>
        #include <envmap_vertex>
        #include <fog_vertex>

        vvUv = uv;
      }
    `,this.fragmentShader=`
      uniform vec3 diffuse;
      uniform float opacity;
      #ifndef FLAT_SHADED
        varying vec3 vNormal;
      #endif
      #include <common>
      #include <dithering_pars_fragment>
      #include <color_pars_fragment>
      #include <uv_pars_fragment>
      #include <map_pars_fragment>
      #include <alphamap_pars_fragment>
      #include <alphatest_pars_fragment>
      #include <alphahash_pars_fragment>
      #include <aomap_pars_fragment>
      #include <lightmap_pars_fragment>
      #include <envmap_common_pars_fragment>
      #include <envmap_pars_fragment>
      #include <fog_pars_fragment>
      #include <specularmap_pars_fragment>
      #include <logdepthbuf_pars_fragment>
      #include <clipping_planes_pars_fragment>
      varying vec2 vvUv;
      void main() {
        vec4 diffuseColor = vec4( diffuse, opacity );
        #include <clipping_planes_fragment>
        #include <logdepthbuf_fragment>
        #include <map_fragment>
        #include <color_fragment>
        #include <alphamap_fragment>
        #include <alphatest_fragment>
        #include <alphahash_fragment>
        #include <specularmap_fragment>
        ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
        #ifdef USE_LIGHTMAP
          vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
          reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
        #else
          reflectedLight.indirectDiffuse += vec3( 1.0 );
        #endif
        #include <aomap_fragment>
        reflectedLight.indirectDiffuse *= diffuseColor.rgb;
        vec3 outgoingLight = reflectedLight.indirectDiffuse;
        #include <envmap_fragment>
        #include <opaque_fragment>

        float circ = length(vvUv - vec2(0.5)) * 1.5;
        gl_FragColor.a = smoothstep(0.5, 0.48, circ);
        gl_FragColor.rgb = mix(gl_FragColor.rgb, vec3(1.0), smoothstep(0.35, 0.37, circ));
        gl_FragColor.rgb = mix(vec3(0.0), gl_FragColor.rgb, gl_FragColor.a);

        gl_FragColor.a += smoothstep(0.75, 0.5, circ) * 0.15;
        gl_FragColor.a = clamp(gl_FragColor.a, 0.0, 1.0);
        // gl_FragColor.a *= 0.9;


        #include <tonemapping_fragment>
        #include <colorspace_fragment>
        #include <fog_fragment>
        #include <premultiplied_alpha_fragment>
        #include <dithering_fragment>
      }
    `}}exports.WiggleRigHelper=M;
